const express = require('express')
const router = new express.Router()

// CONTEXT 

// const Perimeters = require('../model/context/perimeter')
// const Account = require('../model/context/account')
const Connector = require('../model/context/connector')

// SVC
const Names = require('../model/svc/name')
// const Label = require('../model/svc/labels')

// APP
const ResourceSettings = require('../model/app/config')
const Deployments = require('../model/app/deployment')
const Tagging = require('../model/app/tagging')
const Resource = require('../model/app/resource')

// UTILS 
const { bodyQuery, objDocBuilder, tagBuilder, logicalNameBuilder } = require('../src/util/names')
const auth = require('../middleware/auth')
const { discover } = require('../connect/bin/aws')
const { valid } = require('../src/util/compare')

// TODO MIGHT BE A ISSUE THAT PROVIDER WILL EFFECT ACCOUNTS AS ACCOUNTS CAN HAVE A 1:MANY RELATIONSHIP WITH PROVIDERS
// FIX LABELLING ERROR HANDLE, logicalNameBuilder
// NEED TO MOVE SECTIONS INTO INNER FUNCTIONS
    // objectDocument - this will find all elements and 
// NEED TO CREATE A QUICK STATE CREATE ENDPOINT WITH A HTTP REQ FUNCTION 
// TODO EVALUATE POPULATE RATHER
router.post('/resources/create', auth, async (req, res) => {
    try {
        // // USED TO COMBINE QUERY AND THE BODY AND RETURN A SINGLE OBJECT 
        var object = bodyQuery(req.body, req.query)
        // debugging
        // console.log('bodyQuery object =')
        // console.log(object)

        // // USED TO COMBINE OBJECT AND FOUND "MONGO" DOCUMENTS "WITH MANDATORY MODELS" AND RETURN A SINGLE OBJECT 
        object = await objDocBuilder(object)
        // console.log('objDocBuilder object =')
        // console.log(object)

        // ERROR IN CALLING FUNCTION
        if(object.name){
            return res.status(404).send({message: object.message})
        }

        // // TAG BUILDER WILL COMPARE CURRENT OBJECT AND RETURN TAG AND CONFIG FOR THIS RESOURCE
        // // RESOURCE ELEMENT AND CONFIG ELEMENT VERIFICATION "IF ANY MISSING ELEMENTS" PERFORMED
        // // IF THE ELEMENT IS REQUIRED IN BOTH TAG AND CONFIGURATION IT MUST BE DECLARED IN BOTH, SEE LABEL
        // // TODO NEED TO CONFIRM THAT IF STRING FOR TAG IS NOT DEFINED IN abbr THAT A ERROR IS THROWN
        // // > RATHER PERFORM ABOVE WHEN SEEDING, INSERTING abbrS 
        var builder = await tagBuilder(object)
        // ERROR IN CALLING FUNCTION
        if(builder.name){
            // throw new Error(builder.message)
            return res.status(404).send({message: builder.message})
        }
        // debugging
        // console.log('tagBuilder object =')
        // console.log(builder)

        // // COMPARE OBJECT WITH LABEL AND RETURN SCHEMA
        // // RETURN LOGICAL NAME 
        // // TODO FIX ERROR HANDLING LIKE ABOVE TAG BUILDER
        logicalName = await logicalNameBuilder(builder.tag)
        if(logicalName.name){
            return res.status(404).send({message: logicalName.message})
        }
        // debugging
        // console.log('logicalNameBuilder logicalName =')
        // console.log(logicalName)

        if(!object.cart){
            deployment = new Deployments({
                author: object.accountId,
                state: object.nameOnly === true ? 13 : 0
            })
            object.deploymentId = deployment._id
            builder.tag.deploymentId = object.deploymentId
            await deployment.save()
        }


        // TODO DEPRECATE COUNT AS WILL NOT BE NECESSARY WITH ASG
        // IF CALLER/USER WANTS MORE ITEMS WILL NEED TO ITERATE
        // COMMENT BLOCK BELOW IS IN REVIEW, SEE # FOR CURRENT SOLUTION

        // #
        // // SEED RESOURCE
        resource = await new Resource({
            author: object.deploymentId,
            owner: object.accountId,
            resourceType: builder.tag.resourceType,
            logicalName: logicalName,
            userDefined: true
        })
        await resource.save()

        // // SEED NAME
        const name = await new Names({
            author: resource._id, 
            fullName: logicalName
        })
        await name.save()
        // #

        /*
        // COUNT PARAMETER GREATER THEN 1
        const numerator = builder.configuration.count
        var resource = null
        var ln = []

        if(numerator > 1){
            
            var num = 0
            var iteration = 0
            var re = null
            for (let i = 0; i < numerator; i++){
                // console.log('i =', i)
                re = new RegExp(/\d{1,10}$/)
                const mesh = logicalName.match(re)
                iteration = parseInt(mesh[0])
                iteration+=num
                // console.log('count iteration =', iteration)
                const len = iteration.toString().split('').length
                var string = `\\d{1,${len}}$`
                re = new RegExp(string)

                // // SEED RESOURCE
                builder.configuration.count = 1
                resource = await new Resource({
                    author: object.deploymentId,
                    owner: object.accountId,
                    resourceType: builder.tag.resourceType,
                    logicalName: logicalName.replace(re, iteration),
                    userDefined: true
                })
                await resource.save()

                // // SEED NAME
                const name = await new Names({
                    author: resource._id, 
                    fullName: logicalName.replace(re, iteration)
                })
                await name.save()
                ln.push(name.fullName)
                num++
            }
            
        }else{
            // // SEED RESOURCE
            resource = await new Resource({
                author: object.deploymentId,
                owner: object.accountId,
                resourceType: builder.tag.resourceType,
                logicalName: logicalName,
                userDefined: true
            })
            await resource.save()

            // // SEED NAME
            const name = await new Names({
                author: resource._id, 
                fullName: logicalName
            })
            await name.save()
            ln.push(name.fullName)
        }
        // console.log(ln)
        */
        
        // // SEED RESOURCE SETTINGS
        if (builder.configuration){
            const resourceSettings = await new ResourceSettings({
                author : resource._id,
                owner : object.deploymentId,
                resourceType : resource.resourceType,
                ...builder.configuration
            })
            
            await resourceSettings.save()
        }

        // // SEED TAGS 
        // // USING EXISTING DEPLOYMENT/CART FOR RESOURCE TO GROUP RESOURCES
        var tagging = null
        if(object.cart){
            tagging = await Tagging.find({
                author: object.deploymentId
            })
        }else{
            tagging = await new Tagging({
                author: object.deploymentId,
                entries: builder.tag
            })
            // // SAVE COMMON DOCUMENTS 
            await tagging.save()
        }

        res.status(201).send({deploymentId:object.deploymentId})
    } catch (e) {
        // logger.log('error', `${(e.message)}`)
        res.status(500).send(e)
    }
})

// TODO EVAL IF SINGLE CREATE REQUIRED AS MULTI WILL CARTER FOR BOTH REQUESTS
router.post('/resources/create/multiple', auth, async (req, res) => {
    try {
        // // USED TO COMBINE QUERY AND THE BODY AND RETURN A SINGLE OBJECT
        // IF COUNT, SET 1 AS RESOURCE TYPE WILL SET THE COUNT PARAMETER
        if(req.query.count){
            req.query.count = 1
        }
        var object = bodyQuery(req.body, req.query)
        // debugging
        // console.log('bodyQuery object =')
        // console.log(object)

        var array = Array.isArray(object.resourceType) ? object.resourceType : [object.resourceType]
        if (array.includes('STATE')){
            array = ['STATE', 'RGRP', 'AGRP', 'S3', 'AUSR', 'RUSR', 'DYN']
        }
        for (let i = 0; i < array.length; i++){
            var dolly = Object.assign({}, object)
            dolly.resourceType = array[i]

            // // USED TO COMBINE OBJECT AND FOUND "MONGO" DOCUMENTS "WITH MANDATORY MODELS" AND RETURN A SINGLE OBJECT 
            dolly = await objDocBuilder(dolly)
            // console.log('objDocBuilder dolly =')
            // console.log(dolly)

            // ERROR IN CALLING FUNCTION
            if(dolly.name){
                return res.status(404).send({message: dolly.message})
            }

            // // TAG BUILDER WILL COMPARE CURRENT OBJECT AND RETURN TAG AND CONFIG FOR THIS RESOURCE
            // // RESOURCE ELEMENT AND CONFIG ELEMENT VERIFICATION "IF ANY MISSING ELEMENTS" PERFORMED
            // // IF THE ELEMENT IS REQUIRED IN BOTH TAG AND CONFIGURATION IT MUST BE DECLARED IN BOTH, SEE LABEL
            // // TODO NEED TO CONFIRM THAT IF STRING FOR TAG IS NOT DEFINED IN abbr THAT A ERROR IS THROWN
            // // > RATHER PERFORM ABOVE WHEN SEEDING, INSERTING abbrS 
            var builder = await tagBuilder(dolly)
            // ERROR IN CALLING FUNCTION, 
            if(builder.name){
                return res.status(404), ({message: builder.message})
            }object
            // console.log('tagBuilder builder =')
            // console.log(builder)

            // // COMPARE OBJECT WITH LABEL AND RETURN SCHEMA
            // // RETURN LOGICAL NAME 
            // // TODO FIX ERROR HANDLING LIKE ABOVE TAG BUILDER
            logicalName = await logicalNameBuilder(builder.tag)
            if(logicalName.name){
                return res.status(404).send({message: logicalName.message})
            }
            // debugging
            // console.log('logicalNameBuilder logicalName =')
            // console.log(logicalName)

            if(!dolly.cart){
                deployment = new Deployments({
                    author: dolly.accountId,
                    state: dolly.nameOnly === true ? 13 : 0
                })
                // UPDATING CLONED OBJECT 
                object.deploymentId = deployment._id
                builder.tag.deploymentId = object.deploymentId
                object.cart = object.cart !== true ? true : false
                await deployment.save()
            }
            // debugging
            // console.log('deployment =')
            // console.log(deployment)

            // // SEED RESOURCE
            const resource = await new Resource({
                author: object.deploymentId,
                owner: dolly.accountId,
                resourceType: builder.tag.resourceType,
                logicalName: logicalName,
                userDefined: true
            })
            await resource.save()
            // debugging
            // console.log('resource =')
            // console.log(resource)

            // // SEED NAME
            const name = await new Names({
                author: resource._id, 
                fullName: logicalName
            })
            await name.save()
            // debugging
            // console.log('name =')
            // console.log(name)
            
            // // SEED RESOURCE SETTINGS
            if (builder.configuration){
                const resourceSettings = await new ResourceSettings({
                    author : resource._id,
                    owner : object.deploymentId,
                    resourceType : resource.resourceType,
                    ...builder.configuration
                })
                await resourceSettings.save()
            }
            // // SEED TAGS 
            // // USING EXISTING DEPLOYMENT/CART FOR RESOURCE TO GROUP RESOURCES
            var tagging = null
            if(dolly.cart){
                tagging = await Tagging.find({
                    author: object.deploymentId
                })
            }else{
                tagging = await new Tagging({
                    author: object.deploymentId,
                    entries: builder.tag
                })
                // // SAVE COMMON DOCUMENTS 
                await tagging.save()
            }
            // debugging
            // console.log('tagging =')
            // console.log(tagging)
        }

        await res.status(201).send({deploymentId:object.deploymentId})
    } catch (e) {
        // logger.log('error', `${(e.message)}`)
        res.status(500).send(e)
    }
})

router.get('/resources/deployments', auth, async (req, res) => {
    try {
        var Options = {}
        Options.limit = parseInt(req.query.limit) >= 50 ? parseInt(req.query.limit) : 50
        Options.skip = req.query.skip ? req.query.skip : 0
        const deployment = await Deployments.find({}, null, Options)
        res.status(200).send(deployment)
    } catch (e) {
        // logger.log('error', `${(e.message)}`)
        res.status(500).send(e)
    }
})

// TODO JUST EVAL/TESTING IF NECESSARY AS HANDLED IN MAIN CONNECTOR MODEL
router.get('/resources/discovery/:id', async (req, res) => {
    try {
        const connector = await MainConnector.findById(req.params.id)
        if(!connector){
            return res.status(404).send({message:'Connector not found'})
        }
        if(connector.provider === 'AWS'){
            await discover(process.env.AWS_ACCESS_KEY, process.env.AWS_SECRET_KEY, connector)
        }
        res.status(200).send()
    } catch (e) {
        // logger.log('error', `${(e.message)}`)
        res.status(500).send(e)
    }
})

// USED BY SERVICE TO UPDATE LOGICAL ID'S 
router.patch('/resources/update/:id', auth, async (req, res) => {
    const exclude = ['author', 'owner', '_id']
    // console.log('req.body =')
    // console.log(req.body)
    const isValid = valid(req.body, Resource.schema.obj, exclude)
    // console.log('isValid =')
    // console.log(isValid)
    if (!isValid) {
        return res.status(400).send({message:'Please provide a valid input'})
    }
    try {
        const resource = await Resource.findById(req.params.id)
        if (!resource) {
            return res.status(404).send({message:'Not Found'})
        }
        // debugging
        // console.log(resource)
        const body = Object.keys(req.body)
        body.forEach(value => {
            resource[value] = req.body[value]
        })
        await resource.save()
        res.status(201).send(resource)
    } catch (e) {
        res.status(500).send({error: e.message})
    }
})

// USED BY SERVICE TO UPDATE LOGICAL ID'S 
router.patch('/resources/updateSetting/:id', auth, async (req, res) => {
    try {
        var resource = await Resource.findById(req.params.id)
        if (!resource) {
            return res.status(404).send({message:'Not Found'})
        }
        const setting = await ResourceSettings.findOne({
            author: resource.id
        })
        const isValid = valid(req.body, setting.schema.obj, exclude)
        if (!isValid) {
            return res.status(400).send({message:'Please provide a valid input'})
        }
        if (isValid){
            const body = Object.keys(req.body)
            for(let i = 0; i < body.length; i++){
                const value = body[i]
                setting[value] = req.body[value]
            }
            await setting.save()
        }
        res.status(201).send(setting)
    } catch (e) {
        res.status(500).send({error: e.message})
    }
})

router.post('/resources/add/rule/:id', auth, async (req, res) => {
    try {
        // TODO NEED TO PROVIDE A ENDPOINT TO DELETE RULES 
        // await SecurityRules.deleteMany({
        // })
        var group = await Resource.find({
            author: req.params.id,
            resourceType: 'SGRP'
        })
        // debugging
        // console.log('group =')
        // console.log(group.length)
        var setting = null
        for (let x = 0; x < group.length; x ++){
            // console.log('group =')
            // console.log(group[x])
            setting = await ResourceSettings.findOne({
                owner: req.params.id,
                author: group[x]._id
            })
            // console.log('setting =')
            // console.log(setting)
        }
        // debugging
        // console.log('group =')
        // console.log(group)
        if(!setting){
            return res.status(404).send({message:'Group not Found'})
        }
        const resource = await Resource.findOne({
            author: req.params.id,
            resourceType: req.body.forResource
        })
        // console.log('resource =')
        // console.log(resource)
        if(!resource){
            return res.status(404).send({message:'Resource not Found'})
        }
        
        // TODO DEPRECATE SECURITY RULES DOCUMENTS, MOVE TO RESOURCE SETTINGS
        // const securityRule = await SecurityRules.find({
        //     owner: req.params.id,
        //     ...req.body
        // })
        const settings = await ResourceSettings.find({
            owner: req.params.id,
            ...req.body
        })
        // debugging
        // console.log('settings =')
        // console.log(settings)
        if(settings.length !== 0){
            return res.status(404).send({message:'Rule Found'})
        }
        if(group.length >= 1){
            group = group[0]
        }
        // TODO DEPRECATE SECURITY RULES DOCUMENTS, MOVE TO RESOURCE SETTINGS
        // const rule = new SecurityRules({
        //     author: group._id,
        //     owner: req.params.id, 
        //     ...req.body
        // })
        const rule = await new ResourceSettings({
            author: group._id,
            owner: req.params.id, 
            resourceType: group.resourceType,
            ...req.body
        })
        await rule.save()
        res.status(201).send(rule)
    } catch (e) {
        res.status(500).send({error: e.message})   
    }
})

router.get('/resources/query/:id', auth, async (req, res) => {
    try {
        var object = {}
        var resourceType = null

        const deployment = await Deployments.findById(req.params.id)
        if(!deployment){
            return res.status(404).send({message:'Deployment not found'})
        }
        const account = await OrganizationalUnit.findById(deployment.author)
        if(!account){
            return res.status(404).send({message:'Account not found'})
        }
        const tagging = await Tagging.findOne({
            author: deployment._id
        })
        var resources = await Resource.find({
            author: deployment._id
        })
        const connector = await MainConnector.findOne({
            _id: account.owner
        })
        const settings = await ResourceSettings.find({
            owner: deployment._id
        })
        if(!resources){
            return res.status(404).send({message:'Resource not found'})
        }
        if(resources.length > 1){
            resourceType = await Resource.find({
                author: deployment._id
            }).distinct('resourceType')
            if(resourceType.length > 1){
                tagging.entries.resourceType = resourceType.join('-')
                await tagging.save()
            }        
        }
        if(req.query.document === 'resources'){
            if (resources.length > 0){
                for (let i = 0; i < resources.length; i++){
                    if (resources[i]['resourceType'] !== 'SGRP'){
                        // console.log(resources[i])
                        var inner = {}
                        const key = resources[i]['resourceType']
                        // // debugging
                        // console.log('key =')
                        // console.log(key)
                        inner['logicalName'] = resources[i]['logicalName']
                        inner['resourceId'] = resources[i]['id']
                        if (resources[i]['logicalId'] !== 'NULL'){
                            inner['logicalId'] = resources[i]['logicalId']
                        }
                        inner['resourceType'] = resources[i]['resourceType']
                        // JOIN SETTING AND RESOURCE 
                        const setting = await ResourceSettings.findOne({
                            author: inner['resourceId'] 
                        })
                        const clone = setting.toObject()
                        delete clone._id
                        delete clone.author
                        delete clone.owner
                        delete clone.__v
                        if (Object.keys(clone).length > 0){
                            Object.keys(clone).forEach((x) => {
                                const val = clone[x]
                                inner[x] =  val !== typeof String ? val.toString() : val
                            })
                        }
                        object[key] = inner
                    }
                }
            }
            return res.status(200).send({resources: object})
        }
        if(req.query.document === 'resourceArray'){
            // console.log(resources)
            if (resources.length > 0){
                for (let i = 0; i < resources.length; i++){
                    if (resources[i]['resourceType'] !== 'SGRP'){
                        // console.log(resources[i])
                        var inner = {}
                        const key = resources[i]['resourceType']
                        inner['logicalName'] = resources[i]['logicalName']
                        inner['resourceId'] = resources[i]['id']
                        if (resources[i]['logicalId'] !== 'NULL'){
                            inner['logicalId'] = resources[i]['logicalId']
                        }
                        inner['resourceType'] = resources[i]['resourceType']
                        // JOIN SETTING AND RESOURCE 
                        const setting = await ResourceSettings.findOne({
                            author: inner['resourceId'] 
                        })
                        const clone = setting.toObject()
                        delete clone._id
                        delete clone.author
                        delete clone.owner
                        delete clone.__v

                        if (Object.keys(clone).length > 0){
                            Object.keys(clone).forEach((x) => {
                                const val = clone[x]
                                inner[x] =  val !== typeof String ? val.toString() : val
                            })
                        }
                        if(object[key] !== undefined){
                            object[key].push(inner)
                        } 
                        else {
                            object[key] = [inner]
                        }
                    }
                }
            }
            return res.status(200).send({resources: object})
        }
        if(req.query.document === 'security'){
            var ruleObject = {}
            var resourceObject = {}
            if (resources.length > 0){
                resources = resources.filter((x) => {
                    // console.log(x.resourceType === 'SGRP')
                    return x.resourceType === 'SGRP'
                })
                // debugging
                // console.log('resources =')
                // console.log(resources)
                // console.log('count =', resources.length)
                // console.log()
                for (let i = 0; i < resources.length; i++){
                    // const rule = await SecurityRules.find({
                    //     author: resources[i].id
                    // })
                    // debugging

                    var rule = await ResourceSettings.find({
                        author: resources[i].id
                    })
                    // console.log(`rule for, ${resources[i].id} = `)
                    // console.log(rule)
                    // console.log('count =', rule.length)
                    // console.log()
                    if (rule.length > 0){
                        for (let x = 0; x < rule.length; x++){
                            // SECURITY GROUP RESOURCE
                            var resource = {
                                logicalName: resources[i]['logicalName'],
                                resourceType: resources[i]['resourceType'],
                                logicalId: resources[i]['logicalId'],
                                resourceId: resources[i]['_id']
                            }

                            const rkey = rule[x]['forResource']
                            if(resourceObject[rkey] === undefined){
                                resourceObject[rkey] = resource
                            }
                            // RULES
                            var secure = {
                                port: rule[x]['port'], 
                                source: rule[x]['source'],
                                direction: rule[x]['direction'],
                                forResource: rule[x]['forResource'], 
                                toResource: rule[x]['toResource']
                            }
                            const skey = rule[x]['forResource']
                            if(ruleObject[skey] === undefined){
                                ruleObject[skey] = [secure]
                            }
                            else {
                                ruleObject[skey].push(secure)
                            }
                            // debugging
                            // console.log('resource =')
                            // console.log(resource)
                            // console.log('secure =')
                            // console.log(secure)
                        }
                    }
                }
            }
            // TODO TESTING WITH SECURITY GROUP SPECIFIC SOURCE BASED ON TO RESOURCE
            // console.log('resourceObject =')
            // console.log(resourceObject)
            return res.status(200).send({
                resources: resourceObject,
                rules: ruleObject
            })
        }
        if(req.query.document === 'connector'){
            return res.status(200).send({connector: connector})
        }
        // DISCOVERY IS USED FOR FINDING RESOURCES THAT ARE DEPLOYED POST, API AND NOT USER DEFINED
        if(req.query.document === 'discovery'){
            const discovery = await Resource.find({
                owner: account.owner,
                author: account.owner,
                userDefined: false
            })
            // debugging
            // console.log('discovery =')
            // console.log(discovery)
            if (discovery.length > 0){
                for (let i = 0; i < discovery.length; i++){
                    var inner = {}
                    var found = false
                    const key = discovery[i]['resourceType']
                    inner['logicalName'] = discovery[i]['logicalName']
                    inner['logicalId'] = discovery[i]['logicalId']
                    inner['resourceType'] = discovery[i]['resourceType']
                    inner['resourceId'] = discovery[i]['_id']
                    // debugging
                    // console.log('inner =')
                    // console.log(inner)
                    const setting = await ResourceSettings.findOne({
                        author: inner['resourceId']
                    })
                    // debugging
                    // console.log('setting =')
                    // console.log(setting)
                    // TODO, TEMP WILL REMOVE CONDITIONAL ONCE ALL NEW RESOURCES HAVE CREATED SETTINGS AT THE MOMENT NULL BELOW 
                    // TODO, COPY RESOURCE DOCUMENT USE OF RESOURCE SETTINGS 
                    var clone = {}
                    if(setting){
                        clone = setting.toObject()
                        delete clone._id
                        delete clone.author
                        delete clone.owner
                        delete clone.__v
                    } 
                    // TODO EVAL THE BELOW MATCH MIGHT BE TO SPECIFIC
                    const re = new RegExp(account.account, 'i')
                    found = inner['logicalName'].match(re)
                    if(found){
                        inner['accountMatch'] = 'true'
                    } else {
                        inner['accountMatch'] = 'false'
                    }
                    if (Object.keys(clone).length > 0){
                        Object.keys(clone).forEach((x) => {
                            inner[x] = clone[x]
                        })
                    }
                    object[key] = inner
                }
            }
            return res.status(200).send({resources: object})
        }
        // PARENT RESOURCES, WILL FIND RESOURCES THAT ARE CREATED FOR THIS SPECIFIC "OWNER =" ACCOUNT 
        if(req.query.document === 'parent'){
            var parent = await Resource.find({
                owner: account._id,
                userDefined: true
            })
            // debugging
            // console.log('parent =')
            // console.log(parent)
            parent = parent.filter ((x) => {
                return x.logicalId !== 'NULL'
            })
            if (parent.length > 0){
                for (let i = 0; i < parent.length; i++){
                    var inner = {}
                    var found = false
                    const key = parent[i]['resourceType']
                    // const label = await Label.findOne({
                    //     resourceType: key
                    // })
                    // const accountCase = label.isUpperCase ? account.account.toUpperCase() : account.account.toLowerCase()
                    // console.log('accountCase =')
                    // console.log(accountCase)
                    inner['logicalName'] = parent[i]['logicalName']
                    inner['logicalId'] = parent[i]['logicalId']
                    inner['resourceType'] = parent[i]['resourceType']
                    inner['resourceId'] = parent[i]['id']

                    const setting = await ResourceSettings.findOne({
                        author: inner['resourceId']
                    })
                    // TODO, TEMP WILL REMOVE CONDITIONAL ONCE ALL NEW RESOURCES HAVE CREATED SETTINGS AT THE MOMENT NULL BELOW 
                    // TODO, COPY RESOURCE DOCUMENT USE OF RESOURCE SETTINGS 
                    var clone = {}
                    if(setting){
                        clone = setting.toObject()
                        delete clone._id
                        delete clone.author
                        delete clone.owner
                        delete clone.__v
                    } 
                    // TODO EVAL THE BELOW MATCH MIGHT BE TO SPECIFIC 
                    // found = inner['logicalName'].match(accountCase)
                    const re = new RegExp(account.account, 'i')
                    found = inner['logicalName'].match(re)
                    if (found && Object.keys(clone).length > 0){
                        Object.keys(clone).forEach((x) => {
                            inner[x] = clone[x]
                        })
                        object[key] = inner
                    }
                }
            }
            return res.status(200).send({resources: object})
        }
        if(req.query.document === 'tagging'){
            return res.status(200).send({tagging: tagging['entries']})
        }
        if(req.query.document === 'deployment'){
            return res.status(200).send({deployment: deployment})
        }
        if(req.query.document === 'account'){
            return res.status(200).send({account: account})
        }
        if(req.query.document === 'perimeter'){
            const perimeter = await Perimeters.findOne({
                author: connector.id
            })
            if(!perimeter){
                return res.status(404).send({message:'Perimeters not found'})
            }
            object['public'] = perimeter['perimeterLabel']
            object['private'] = perimeter['backOfficeLabel']
            object['internet'] = perimeter['breakoutLabel']
            object['default'] = '*'
            return res.status(200).send({perimeter: object})
        }
        if(req.query.document === 'state'){
            if(!account.remoteStateReadyEnabled){
                return res.status(500).send({message:'Bad state, Repair'})
            }
            const state = await Resource.find({
                author: account.remoteStateDeploymentId
            })
            if(!state){
                return res.status(404).send({message:'State not found'})
            }
            var result = {}
            state.filter ((x) => {
                // console.log(x)
                if (x.resourceType === 'DYN' || x.resourceType === 'S3') {
                    result[x.resourceType] = x.logicalName
                }
            })
            // console.log(result)
            return res.status(200).send(result)
        }
        res.status(200).send({deployment, resources, tagging, settings})
    } catch (e) {
        // logger.log('error', `${(e.message)}`)
        res.status(500).send(e)
    }
})

router.get('/resources/status/:id', auth, async (req, res) => {
    try {
        const deployment = await Deployments.findById(req.params.id)
        if (!deployment){ 
            return res.status(404).send({message:'Deployment not found'})
        }
        if (req.query.state){
            deployment.state = req.query.state
            await deployment.save()
        }
        res.status(200).send(deployment)
    } catch (e) {
        // logger.log('error', `${(e.message)}`)
        res.status(500).send(e)
    }
})

router.delete('/resources/delete/:id', auth, async (req, res) => {
    try {
        const resource = await Resource.deleteOne({
            _id: req.params.id
        })
        // const deployment = await Deployments.find({
        //     author: resource.owner
        // })
        if(!resource){
            return res.status(404).send({message:'Resource not Found'})
        }
        // if(!deployment){
        //     return res.status(404).send({message:'Deployment not Found'})
        // }
        // if(deployment.state !== 0 || deployment.state !== 8 || deployment.state !== 13){
        //     return res.status(404).send({message:'Deployment active'})
        // }
        res.status(200).send()
    } catch (e) {
        res.status(500).send({error: e.message})
    }
})


module.exports = router